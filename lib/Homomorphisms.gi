###############################################################################
##
## InducedHomomorphism( epi1, epi2, hom )
##
InstallGlobalFunction(
	InducedHomomorphism,
	function ( epi1, epi2, hom )
		local GM, HN, ind, inv;
		GM := ImagesSource( epi2 );
		HN := ImagesSource( epi1 );
		ind := function( h )
			return ImagesRepresentative(
				epi2, ImagesRepresentative(
					hom, PreImagesRepresentative(
						epi1, h
					)
				)
			);
		end;
		inv := function( g )
			return ImagesRepresentative(
				epi1, PreImagesRepresentative(
					hom, PreImagesRepresentative(
						epi2, g
					)
				)
			);
		end;
		return GroupHomomorphismByFunction(	HN, GM, ind, false, inv );
	end
);


###############################################################################
##
## RestrictedHomomorphism( hom, N, M )
##
InstallGlobalFunction(
	RestrictedHomomorphism,
	function ( hom, N, M )
		local res, inv;
		res := function( n )
			return ImagesRepresentative( hom, n );
		end;
		inv := function( m )
			return PreImagesRepresentative( hom, m );
		end;
		return GroupHomomorphismByFunction( N, M, res, false, inv );
	end
);


###############################################################################
##
## RepresentativesHomomorphismClasses2Generated@( G )
##
##  Note: this is essentially the code of AllHomomorphismClasses, but with some
##  minor changes to remove redundant code. It assumes H is generated by
##  exactly 2 elements.
##
RepresentativesHomomorphismClasses2Generated@ := function( H, G )
	local cl, cnt, bg, bw, bo, bi, k, gens, go, imgs, params, i, prod;
	cl := ConjugacyClasses( G );
	bw := infinity;
	bo := [ 0, 0 ];
	cnt := 0;
	repeat
		if cnt = 0 then
			gens := SmallGeneratingSet( H );
		else
			repeat
				gens := [ Random( H ), Random( H ) ];
				for k in [ 1, 2 ] do
					go := Order( gens[k] );
					if Random( 1, 6 ) = 1 then
						gens[k] := gens[k] ^ ( go / Random( Factors( go ) ) );
					fi;
				od;
			until IndexNC( H, SubgroupNC( H, gens ) ) = 1;
		fi;
		go := List( gens, Order );
		imgs := List( go, i -> Filtered( 
			cl, 
			j -> IsInt( i / Order( Representative( j ) ) )
		));
		prod := Product( imgs, i -> Sum( i, Size ) );
		if prod < bw then
			bg := gens;
			bo := go;
			bi := imgs;
			bw := prod;
		elif Set( go ) = Set( bo ) then
			cnt := cnt + Int( bw / Size( G ) * 3 );
		fi;
		cnt := cnt + 1;
	until bw / Size( G ) * 3 < cnt;
		params := rec(
		gens := bg,
		from := H
	);
	return MorClassLoop( G, bi, params, 9 );
end;


###############################################################################
##
## RepresentativesHomomorphismClassesAbelian@( G )
##
##
RepresentativesHomomorphismClassesAbelian@ := function( H, G )
	local gensH, gensG, imgs, h, oh, imgsG, g, og, pows, e;
	gensH := IndependentGeneratorsOfAbelianGroup( H );
	gensG := IndependentGeneratorsOfAbelianGroup( G );
	imgs := [];
	for h in gensH do
		oh := Order( h );
		imgsG := [];
		for g in gensG do
			og := Order( g );
			pows := Filtered( [0..og-1], x -> ((x*oh) mod og) = 0 );
			Add( imgsG, List( pows, x -> g^x ) );
		od;
		Add( imgs, List( Cartesian( imgsG ), Product ) );
	od;
	e := [];
	for imgsG in IteratorOfCartesianProduct( imgs ) do
		Add( e, GroupHomomorphismByImagesNC( H, G, gensH, imgsG ) );
	od;
	return e;
end;


###############################################################################
##
## RepresentativesHomomorphismClasses( H, G )
##
InstallGlobalFunction(
	RepresentativesHomomorphismClasses,
	function ( H, G )
		IsFinite( H );
		IsAbelian( H );
		IsCyclic( H );
		IsTrivial( H );
		IsFinite( G );
		IsAbelian( G );
		IsTrivial( G );
		return RepresentativesHomomorphismClassesOp( H, G );
	end
);


###############################################################################
##
## RepresentativesHomomorphismClassesOp( H, G )
##
InstallMethod(
	RepresentativesHomomorphismClassesOp,
	"for trivial source",
	[ IsGroup and IsFinite and IsTrivial, IsGroup and IsFinite ],
	3*SUM_FLAGS+4,
	function ( H, G )
		if not IsTrivial( H ) then TryNextMethod(); fi;
		return [ GroupHomomorphismByImagesNC( 
			H, G,
			[ One( H ) ], [ One( G ) ]
		)];
	end
);

InstallMethod(
	RepresentativesHomomorphismClassesOp,
	"for trivial range",
	[ IsGroup and IsFinite, IsGroup and IsFinite and IsTrivial ],
	3*SUM_FLAGS+4,
	function ( H, G )
		return [ GroupHomomorphismByFunction( 
			H, G,
			h -> One( G )
		)];
	end
);

InstallMethod(
	RepresentativesHomomorphismClassesOp,
	"for non-abelian source and abelian range",
	[ IsGroup and IsFinite, IsGroup and IsFinite and IsAbelian ],
	2*SUM_FLAGS+3,
	function ( H, G )
		local p;
		if IsAbelian( H ) then TryNextMethod(); fi;
		p := NaturalHomomorphismByNormalSubgroupNC( H, DerivedSubgroup( H ) );
		return List( 
		RepresentativesHomomorphismClasses( ImagesSource( p ), G ),
			hom -> p*hom
		);
	end
);

InstallMethod(
	RepresentativesHomomorphismClassesOp,
	"for abelian source and abelian range",
	[ IsGroup and IsFinite and IsAbelian, IsGroup and IsFinite and IsAbelian ],
	SUM_FLAGS+2,
	RepresentativesHomomorphismClassesAbelian@
);

InstallMethod(
	RepresentativesHomomorphismClassesOp,
	"for finite cyclic source and finite range",
	[ IsGroup and IsFinite and IsCyclic, IsGroup and IsFinite ],
	SUM_FLAGS+2,
	function ( H, G )
		local h, o, L;
		if IsAbelian( G ) then TryNextMethod(); fi;
		h := MinimalGeneratingSet( H )[1];
		o := Order( h );
		L := List( ConjugacyClasses( G ), Representative );
		L := Filtered( L, g -> IsInt( o / Order( g ) ) );
		return List( L, g -> GroupHomomorphismByImagesNC( 
			H, G,
			[ h ], [ g ]
		));
	end
);

InstallMethod(
	RepresentativesHomomorphismClassesOp,
	"for finite 2-generated source and finite range",
	[ IsGroup and IsFinite, IsGroup and IsFinite ],
	1,
	function ( H, G )
		if (
			not IsPermGroup( H ) and not IsPermGroup( G ) or
			Size( SmallGeneratingSet( H ) ) > 2
		) then TryNextMethod(); fi;
		return RepresentativesHomomorphismClasses2Generated@( H, G );
	end
);

InstallMethod(
	RepresentativesHomomorphismClassesOp,
	"for abitrary finite groups",
	[ IsGroup and IsFinite, IsGroup and IsFinite ],
	0,
	function( H, G )
		local asAuto, AutH, AutG, gensAutG, gensAutH, Conj, c, r, ImgReps,
		ImgOrbits, KerOrbits, Pairs, Heads, i, kerOrbit, N, possibleImgs, p, Q,
		idQ, head, Tails, j, imgOrbit, M, AutM, InnGM, tail, e, iso, Isos;

		# Step 1: Determine automorphism groups of H and G
		asAuto := function( A, aut ) return ImagesSet( aut, A ); end;
		AutH := AutomorphismGroup( H );
		AutG := AutomorphismGroup( G );
		gensAutG := SmallGeneratingSet( AutG );
		gensAutH := SmallGeneratingSet( AutH );
		
		# Step 2: Determine all possible kernels and images, i.e.
		# the normal subgroups of H and the subgroups of G
		Conj := ConjugacyClassesSubgroups( G );
		for c in Conj do
			r := Representative( c );
			SetNormalizerInParent( r, StabilizerOfExternalSet( c ) );
		od;
		
		ImgReps := List( Conj, Representative );
		ImgOrbits := OrbitsDomain(
			AutG, Flat( List( Conj, List ) ),
			gensAutG, gensAutG,
			asAuto
		);
		ImgOrbits := List( ImgOrbits, x -> Filtered( ImgReps, y -> y in x ) );
		KerOrbits := OrbitsDomain(
			AutH, NormalSubgroups( H ),
			gensAutH, gensAutH,
			asAuto
		);
		
		# Step 3: Calculate info on kernels
		Pairs := [];
		Heads := [];
		Isos := [];
		for i in [ 1 .. Size( KerOrbits ) ] do
			kerOrbit := KerOrbits[i];
			N := kerOrbit[1];
			possibleImgs := Filtered( 
				[ 1 .. Size( ImgOrbits ) ], j ->
				Size( ImgOrbits[j][1] ) = IndexNC( H, N )
			);
			if IsEmpty( possibleImgs ) then
				continue;
			fi;
			Isos[i] := [];
			p := NaturalHomomorphismByNormalSubgroupNC( H, N );
			Q := ImagesSource( p );
			p := RestrictedHomomorphism( p, H, Q );
			
			for j in possibleImgs do
				M := ImgOrbits[j][1];
				iso := IsomorphismGroups( Q, M );
				if iso <> fail then
					Isos[i][j] := p*iso;
					Add( Pairs, [ i, j ] );
				fi;
			od;
			
			if not IsEmpty( SetX( Pairs, x -> x[1] = i, x -> x[1] ) ) then
				Heads[i] := List(
					kerOrbit,
					x -> RepresentativeAction( AutH, N, x, asAuto )
				);
			fi;
		od;
		
		# Step 4: Calculate info on images
		Tails := [];
		for j in Set( Pairs, x -> x[2] ) do
			imgOrbit := ImgOrbits[j];
			M := imgOrbit[1];
			AutM := AutomorphismGroup( M );
			InnGM := SubgroupNC( AutM, List( 
					GeneratorsOfGroup( NormalizerInParent( M ) ),
					g ->  ConjugatorAutomorphismNC( M, g )
			));
			head := RightTransversal( AutM, InnGM );
			tail := List( 
				imgOrbit, 
				x -> RepresentativeAction( AutG, M, x, asAuto )
			);
			head := List( head, x -> GroupHomomorphismByImagesNC( M, G,
				MappingGeneratorsImages( x )[1],
				MappingGeneratorsImages( x )[2]
			));
			Tails[j] := ListX( head, tail, \* );
		od;
		
		# Step 5: Calculate the homomorphisms
		e := [];
		for p in Pairs do
			head := Heads[ p[1] ];
			tail := Tails[ p[2] ];
			iso := Isos[ p[1] ][ p[2] ];
			if Length( head ) < Length( tail ) then
				head := head*iso;
			else
				tail := iso*tail;
			fi;
			Append( e, ListX( head, tail, \* ) );
		od;
		return e;
	end
);


###############################################################################
##
## RepresentativesEndomorphismClasses( H, G )
##
InstallGlobalFunction(
	RepresentativesEndomorphismClasses,
	function ( G )
		IsFinite( G );
		IsAbelian( G );
		IsTrivial( G );
		return RepresentativesEndomorphismClassesOp( G );
	end
);


###############################################################################
##
## RepresentativesEndomorphismClassesOp( G )
##
InstallMethod(
	RepresentativesEndomorphismClassesOp,
	"for trivial group",
	[ IsGroup and IsTrivial ],
	2*SUM_FLAGS+3,
	function ( G )
		return [ GroupHomomorphismByImagesNC(
			G, G,
			[ One( G ) ], [ One( G ) ]
		)];
	end
);

InstallMethod(
	RepresentativesEndomorphismClassesOp,
	"for finite abelian group",
	[ IsGroup and IsFinite and IsAbelian ],
	SUM_FLAGS+2,
	function ( G )
		return RepresentativesHomomorphismClassesAbelian@( G, G );
	end
);

InstallMethod(
	RepresentativesEndomorphismClassesOp,
	"for finite 2-generated group",
	[ IsGroup and IsFinite ],
	1,
	function ( G )
		if (
			not IsPermGroup( G ) or
			Size( SmallGeneratingSet( G ) ) <> 2
		) then TryNextMethod(); fi;
		return RepresentativesHomomorphismClasses2Generated@( G, G );
	end
);

InstallMethod(
	RepresentativesEndomorphismClassesOp,
	"for abitrary finite group",
	[ IsGroup and IsFinite ],
	0,
	function( G )
		local asAuto, AutG, gensAutG, Conj, c, r, norm, SubReps, SubOrbits,
		Pairs, Proj, Reps, i, subOrbit, N, possibleImgs, p, Q, idQ, head,
		Tails, j, M, AutM, InnGM, tail, e, InnG, iso, Isos;

		# Step 1: Determine automorphism group of G
		asAuto := function( A, aut ) return ImagesSet( aut, A ); end;
		AutG := AutomorphismGroup( G );
		gensAutG := SmallGeneratingSet( AutG );

		# Step 2: Determine all possible kernels and images, i.e.
		# the (normal) subgroups of G
		Conj := ConjugacyClassesSubgroups( G );
		for c in Conj do
			r := Representative( c );
			norm := StabilizerOfExternalSet( c );
			SetIsNormalInParent( r, IndexNC( G, norm ) = 1 );
			SetNormalizerInParent( r, norm );
		od;

		SubReps := List( Conj, Representative );
		SubOrbits := OrbitsDomain(
			AutG, Flat( List( Conj, List ) ),
			gensAutG, gensAutG,
			asAuto
		);
		SubOrbits := List( SubOrbits, x -> Filtered( SubReps, y -> y in x ) );

		# Step 3: Calculate info on kernels
		Isos := [];
		Pairs := [];
		Proj := [];
		Reps := [];
		for i in [ 1 .. Size( SubOrbits ) ] do
			subOrbit := SubOrbits[i];
			N := subOrbit[1];
			if IsTrivial( N ) or not IsNormalInParent( N ) then
				continue;
			fi;
			possibleImgs := Filtered( 
				[ 1 .. Size( SubOrbits ) ], j ->
				Size( SubOrbits[j][1] ) = IndexNC( G, N )
			);
			if IsEmpty( possibleImgs ) then
				continue;
			fi;
			p := NaturalHomomorphismByNormalSubgroupNC( G, N );
			Q := ImagesSource( p );
			p := RestrictedHomomorphism( p, G, Q );
			
			
			Isos[i] := [];
			for j in possibleImgs do
				M := SubOrbits[j][1];
				iso := IsomorphismGroups( Q, M );
				if iso <> fail then
					Isos[i][j] := p*iso;
					Add( Pairs, [ i, j ] );
				fi;
			od;
			
			if not IsEmpty( SetX( Pairs, x -> x[1] = i, x -> x[1] ) ) then
				Reps[i] := List( 
					subOrbit,
					x -> RepresentativeAction( AutG, N, x, asAuto )
				);
				Proj[i] := p;
			fi;
		od;

		# Step 4: Calculate info on images
		Tails := [];
		for j in Set( Pairs, x -> x[2] ) do
			subOrbit := SubOrbits[j];
			M := subOrbit[1];
			AutM := AutomorphismGroup( M );
			InnGM := SubgroupNC( AutM, List( 
					GeneratorsOfGroup( NormalizerInParent( M ) ),
					g ->  ConjugatorAutomorphismNC( M, g )
			));
			head := RightTransversal( AutM, InnGM );
			if not IsBound( Reps[j] ) then
				tail := List(
					subOrbit,
					x -> RepresentativeAction( AutG, M, x, asAuto )
				);
			else
				tail := Reps[j];
			fi;
			head := List( head, x -> GroupHomomorphismByImagesNC( M, G,
				MappingGeneratorsImages( x )[1],
				MappingGeneratorsImages( x )[2]
			));
			Tails[j] := ListX( head, tail, \* );
		od;

		e := [];
		InnG := InnerAutomorphismsAutomorphismGroup( AutG );
		Append( e, List( RightTransversal( AutG, InnG ) ) );

		# Step 5: Calculate the homomorphisms
		for p in Pairs do
			head := Reps[ p[1] ];
			tail := Tails[ p[2] ];
			iso := Isos[ p[1] ][ p[2] ];
			if Length( head ) < Length( tail ) then
				head := head*iso;
			else
				tail := iso*tail;
			fi;
			Append( e, ListX( head, tail, \* ) );
		od;
		return e;
	end
);
