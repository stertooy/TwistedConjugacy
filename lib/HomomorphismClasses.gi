###############################################################################
##
## Fingerprint@( G )
##
##  Note: this is an expanded version of code suggested by A. Hulpke at
##  https://math.stackexchange.com/q/4113275
##
Fingerprint@ := function( G )
	if IdGroupsAvailable( Size( G ) ) then
		return IdGroup( G );
    elif IsAbelian( G ) then
        return Collected( AbelianInvariants( G ) );
	else 
		return Collected( List(
			ConjugacyClasses( G ),
			c -> [ Order( Representative( c ) ), Size( c ) ]
		));
	fi;
end;


###############################################################################
##
## RepresentativesHomomorphismClasses2Generated@( G )
##
##  Note: this is essentially the code of AllHomomorphismClasses, but with some
##  minor changes to remove redundant code. It assumes H is generated by
##  exactly 2 elements.
##
RepresentativesHomomorphismClasses2Generated@ := function( H, G )
	local cl, cnt, bg, bw, bo, bi, k, gens, go, imgs, params, i, prod;
	cl := ConjugacyClasses( G );
	bw := infinity;
	bo := [ 0, 0 ];
	cnt := 0;
	repeat
		if cnt = 0 then
			gens := SmallGeneratingSet( H );
		else
			repeat
				gens := [ Random( H ), Random( H ) ];
				for k in [ 1, 2 ] do
					go := Order( gens[k] );
					if Random( 1, 6 ) = 1 then
						gens[k] := gens[k] ^ ( go / Random( Factors( go ) ) );
					fi;
				od;
			until IndexNC( H, SubgroupNC( H, gens ) ) = 1;
		fi;
		go := List( gens, Order );
		imgs := List( go, i -> Filtered( 
            cl, 
            j -> IsInt( i / Order( Representative( j ) ) )
        ));
		prod := Product( imgs, i -> Sum( i, Size ) );
		if prod < bw then
			bg := gens;
			bo := go;
			bi := imgs;
			bw := prod;
		elif Set( go ) = Set( bo ) then
			cnt := cnt + Int( bw / Size( G ) * 3 );
		fi;
		cnt := cnt + 1;
	until bw / Size( G ) * 3 < cnt;
	params := rec(
		gens := bg,
		from := H
	);
	return MorClassLoop( G, bi, params, 9 );
end;


###############################################################################
##
## RepresentativesHomomorphismClassesMGenerated@( G )
##
##  Note: this is an expanded version of code suggested by A. Hulpke at
##  https://math.stackexchange.com/q/4113275
##
## Todo: check if projections p are surjective!!
RepresentativesHomomorphismClassesMGenerated@ := function( H, arg... )
    local G, isEndo, asAuto, AutH, AutG, Imgs, c, r, Kers, newImgs, i, Pairs,
    KerOrbits, Quos, Heads, kerOrbit, N, possibleImgs, p, Q, idQ, ImgOrbits,
    Tails, j, newPairs, orbs, reps, n, k, imgOrbit, M, AutM, InnGM, head, tail,
    inc, e, InnH, le, iso;
	if Length( arg ) = 0 then
		G := H;
		isEndo := true;
	else
		G := arg[1];
		isEndo := false;
	fi;
    
    # Step 1: Determine automorphism groups of H and G
	asAuto := function( A, aut ) return ImagesSet( aut, A ); end;
	AutH := AutomorphismGroup( H );
	AutG := AutomorphismGroup( G );
    
    # Step 2: Determine all possible kernels and images, i.e.
    # the normal subgroups of H and the subgroups of G
    Imgs := ConjugacyClassesSubgroups( G );
    for c in Imgs do
        r := Representative( c );
        SetIsNormalInParent( r, IsTrivial( c ) );
        SetNormalizerInParent( r, StabilizerOfExternalSet( c ) );
    od;
	if isEndo then
		Kers := Filtered( List( Imgs, Representative ), IsNormalInParent );
	else
		Kers := NormalSubgroups( H );
	fi;
    
    # Step 3: Group images together that are mapped to each other by some
    # automorphism of G
    
    # Step 3.1: Filter images by size of conjugacy class
    Imgs := List( 
        Set( Imgs, Size ), 
        i -> Filtered( Imgs, x -> Size( x ) = i )
    );
    
    # Step 3.2: Filter images by size of representative
    newImgs := [];
    for i in Imgs do
        if Length( i ) = 1 then
            Add( newImgs, i );
            continue;
        fi;
        Append( newImgs, List(
            Set( i, x -> Size( Representative( x ) ) ),
            j -> Filtered( i, x -> Size( Representative( x ) ) = j )
        ));
    od;
    Imgs := newImgs;
    
    # Step 3.3: Filter images by fingerprints
    newImgs := [];
    for i in Imgs do
        if Length( i ) = 1 then
            Add( newImgs, i );
            continue;
        fi;
        Append( newImgs, List(
            Set( i, x -> Fingerprint@( Representative( x ) ) ),
            j -> Filtered( i, x -> Fingerprint@( Representative( x ) ) = j )
        ));
    od;
    Imgs := newImgs;
    
    # Step 4: Find pairs of kernels and images that can be mapped to each other
    Pairs := [];
    KerOrbits := [];
    Quos := [];
    Heads := [];
    for kerOrbit in OrbitsDomain( AutH, Kers, asAuto ) do
        N := Representative( kerOrbit );
        if isEndo and IsTrivial( N ) then
            continue;
        fi;
        possibleImgs := Filtered( 
            [ 1 .. Size( Imgs ) ], 
            i -> Size( Representative( Imgs[i][1] ) ) = IndexNC( H, N )
        );
		if IsEmpty( possibleImgs ) then
			continue;
		fi;
        p := NaturalHomomorphismByNormalSubgroupNC( H, N );
		Q := ImagesSource( p );
        if not IsSurjective( p ) then
            p := RestrictedHomomorphism( p, H, Q );
        fi;
		idQ := Fingerprint@( Q );
		possibleImgs := Filtered( 
            possibleImgs, 
            i -> Fingerprint@( Representative( Imgs[i][1] ) ) = idQ
        );
        if IsEmpty( possibleImgs ) then
			continue;
		fi;
        Add( KerOrbits, kerOrbit );
        Add( Quos, Q );
        Add( Heads, List( 
            kerOrbit, 
            i -> RepresentativeAction( AutH, N, i, asAuto )*p
        ));
        Append( Pairs, List( possibleImgs, j -> [ Size( KerOrbits ), j ] ) );
    od;
    
    # Step 5: Calculate info on images
    ImgOrbits := [];
    Tails := [];
    j := 0;
    newPairs := [];
    for i in Set( Pairs, x -> x[2] ) do
        if Length( Imgs[i] ) = 1 then
            # Length one, hence just one conjugacy class
            orbs := [[ Representative( Imgs[i][1] ) ]];
        else
            reps := List( Imgs[i], Representative );
            orbs := List( Imgs[i], List );
            orbs := OrbitsDomain( AutG, Flat( orbs ), asAuto );
            orbs := List( orbs, x -> Intersection2( x, reps ) );
        fi;
        n := Length( orbs );
        for k in Filtered( Pairs, x -> x[2] = i ) do
            Append( newPairs, List( [1..n], x -> [ k[1], j+x ] ) );
        od;
        j := j + n;
        for imgOrbit in orbs do
            Add( ImgOrbits, imgOrbit );
            M := Representative( imgOrbit );

            AutM := AutomorphismGroup( M );
            InnGM := SubgroupNC( AutM, List( 
                GeneratorsOfGroup( NormalizerInParent( M ) ),
                g ->  ConjugatorAutomorphismNC( M, g )
            ));
            head := List( RightTransversal( AutM, InnGM ) );
            tail := List( 
                imgOrbit, 
                x -> RepresentativeAction( AutG, M, x, asAuto )
            );
            inc := GroupHomomorphismByFunction( M, G, x -> x );
            if Length( head ) < Length( tail ) then
                head := List( head, x -> x*inc );
            else
                tail := List( tail, x -> inc*x );
            fi;
            Add( Tails, ListX( head, tail, \* ) );
        od;
    od;
    Pairs := newPairs;
    
    # Step 6: Calculate the homomorphisms
    e := [];
    if isEndo then
		InnH := InnerAutomorphismsAutomorphismGroup( AutH );
		Append( e, List( RightTransversal( AutH, InnH ) ) );
	fi;
	for i in [ 1 .. Length( KerOrbits ) ] do
        kerOrbit := KerOrbits[i];
		Q := Quos[i];
		le:=[];
        for j in List( Filtered( Pairs, x -> x[1] = i ), y -> y[2] ) do
            imgOrbit := ImgOrbits[j];
			M := imgOrbit[1];
			iso := IsomorphismGroups( Q, M );
			if iso <> fail then
                head := Heads[i];
				tail := Tails[j];
                if Length( head ) < Length( tail ) then
                    head := List( head, x -> x*iso );
                else
                    tail := List( tail, x -> iso*x );
                fi;
                Append( le, ListX( head, tail, \* ) );
			fi;
		od;
		Append(e,le);
	od;
	return e;
end;


###############################################################################
##
## RepresentativesHomomorphismClasses( H, G )
##
InstallMethod(
	RepresentativesHomomorphismClasses,
	"for trivial source",
	[ IsGroup, IsGroup ],
    5,
	function ( H, G )
        if not IsTrivial( H ) then
            TryNextMethod();
        fi;
        return [ GroupHomomorphismByImagesNC( H, G, [ One( H ) ], [ One( G ) ] ) ];
	end
);

InstallMethod(
	RepresentativesHomomorphismClasses,
	"for trivial range",
	[ IsGroup, IsGroup ],
    4,
	function ( H, G )
        if not IsTrivial( G ) then
            TryNextMethod();
        fi;
        return [ GroupHomomorphismByFunction( H, G, h -> One( G ) ) ];
	end
);


InstallMethod(
	RepresentativesHomomorphismClasses,
	"for non-abelian source and abelian range",
	[ IsGroup, IsGroup ],
    3,
	function ( H, G )
        local p;
        if IsAbelian( H ) or not IsAbelian( G ) then
            TryNextMethod();
        fi;
        p := NaturalHomomorphismByNormalSubgroupNC( H, DerivedSubgroup( H ) );
        return List( RepresentativesHomomorphismClasses( ImagesSource( p ), G ), hom -> p*hom );
	end
);

InstallMethod(
	RepresentativesHomomorphismClasses,
	"for finite cyclic source and finite range",
	[ IsGroup, IsGroup ],
    2,
	function ( H, G )
        local h, o, L;
        if not IsCyclic( H ) or not IsFinite( H ) or not IsFinite( G ) then
            TryNextMethod();
        fi;
        h := MinimalGeneratingSet( H )[1];
        o := Order( h );
        if IsAbelian( G ) then
            L := List( G );
        else
            L := List( ConjugacyClasses( G ), Representative );
        fi;
        L := Filtered( L, g -> IsInt( o / Order( g ) ) );
        return List( L, g -> GroupHomomorphismByImagesNC( H, G, [ h ], [ g ] ) );
	end
);


InstallMethod(
	RepresentativesHomomorphismClasses,
	"for finite 2-generated source",
	[ IsGroup, IsGroup ],
    1,
	function ( H, G )
        local s;
        s := SmallGeneratingSet( H );
        if Size( s ) > 2 and IsFinite( G ) or not IsFinite( H ) then
            TryNextMethod();
        fi;
		return RepresentativesHomomorphismClasses2Generated@( H, G );
	end
);

InstallMethod(
	RepresentativesHomomorphismClasses,
    "for abitrary finite groups",
	[ IsGroup, IsGroup ],
    0,
    function ( H, G )
		if not IsFinite( H ) or not IsFinite( G ) then
			TryNextMethod();
		fi;
		return RepresentativesHomomorphismClassesMGenerated@( H, G );
	end
);

###############################################################################
##
## RepresentativesEndomorphismClasses( G )
##
InstallMethod(
	RepresentativesEndomorphismClasses,
	"for trivial group",
	[ IsGroup ],
    5,
	function ( G )
        if not IsTrivial( G ) then
            TryNextMethod();
        fi;
        return [ GroupHomomorphismByImagesNC( G, G, [ One( G ) ], [ One( G ) ] ) ];
	end
);


InstallMethod(
	RepresentativesEndomorphismClasses,
	"for finite cyclic group",
	[ IsGroup ],
    2,
	function ( G )
        local g, o;
        if not IsCyclic( G ) or not IsFinite( G ) then
            TryNextMethod();
        fi;
        g := MinimalGeneratingSet( G )[1];
        o := Order( g );
        return List( DivisorsInt( o ), k -> GroupHomomorphismByImagesNC( G, G, [ g ], [ g^k ] ) );
	end
);


InstallMethod(
	RepresentativesEndomorphismClasses,
	"for finite 2-generated source",
	[ IsGroup ],
    1,
	function ( G )
        local s;
        s := SmallGeneratingSet( G );
        if Size( s ) > 2 or not IsFinite( G ) then
            TryNextMethod();
        fi;
		return RepresentativesHomomorphismClasses2Generated@( G, G );
	end
);


InstallMethod(
	RepresentativesEndomorphismClasses,
    "for abitrary finite groups",
	[ IsGroup ],
    0,
    function ( G )
		if not IsFinite( G ) then
			TryNextMethod();
		fi;
		return RepresentativesHomomorphismClassesMGenerated@( G );
	end
);
